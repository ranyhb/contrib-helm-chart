{{- if and .Values.postgresql.enabled .Values.postgresqlMigration.enabled }}
{{- $postgresqlFullname := include "redash.postgresql.fullname" . }}
apiVersion: batch/v1
kind: Job
metadata:
  name: "{{ .Release.Name }}-postgres-migration"
  labels:
    {{- include "redash.labels" . | nindent 4 }}
    app.kubernetes.io/component: postgres-migration
  annotations:
    # This hook runs BEFORE the upgrade to dump the database
    "helm.sh/hook": pre-upgrade
    "helm.sh/hook-weight": "-10"
    "helm.sh/hook-delete-policy": before-hook-creation,hook-succeeded
spec:
  ttlSecondsAfterFinished: 3600
  template:
    metadata:
      name: "{{ .Release.Name }}-postgres-migration"
      labels:
        {{- include "redash.selectorLabels" . | nindent 8 }}
        app.kubernetes.io/component: postgres-migration
    spec:
      serviceAccountName: {{ include "redash.serviceAccountName" . }}
      restartPolicy: Never
      containers:
      - name: postgres-dump
        image: postgres:15-alpine
        command:
          - /bin/sh
          - -c
          - |
            set -e
            echo "=== PostgreSQL Migration Pre-Upgrade Hook ==="
            echo "Checking for existing PostgreSQL 15 instance..."
            
            # Install kubectl (needed for scaling StatefulSet and managing PVCs)
            apk add --no-cache curl > /dev/null 2>&1
            KUBECTL_VERSION="v1.30.0"
            curl -LO "https://dl.k8s.io/release/${KUBECTL_VERSION}/bin/linux/amd64/kubectl" > /dev/null 2>&1
            chmod +x kubectl && mv kubectl /usr/local/bin/kubectl > /dev/null 2>&1 || true
            
            # Try to connect to old PostgreSQL instance
            OLD_PG_HOST="{{ $postgresqlFullname }}"
            OLD_PG_USER="{{ .Values.postgresql.auth.username }}"
            OLD_PG_DB="{{ .Values.postgresql.auth.database }}"
            OLD_PG_PASSWORD="{{ .Values.postgresql.auth.password }}"
            
            # Wait for PostgreSQL to be ready
            until PGPASSWORD="$OLD_PG_PASSWORD" psql -h "$OLD_PG_HOST" -U "$OLD_PG_USER" -d "$OLD_PG_DB" -c "SELECT 1;" > /dev/null 2>&1; do
              echo "Waiting for PostgreSQL to be ready..."
              sleep 2
            done
            
            # Check PostgreSQL version
            PG_VERSION=$(PGPASSWORD="$OLD_PG_PASSWORD" psql -h "$OLD_PG_HOST" -U "$OLD_PG_USER" -d "$OLD_PG_DB" -t -c "SELECT version();" | grep -oE '[0-9]+\.[0-9]+' | head -1)
            echo "Current PostgreSQL version: $PG_VERSION"
            
            # Only proceed if PostgreSQL version is 15.x (major version 15)
            if echo "$PG_VERSION" | grep -qE '^15\.'; then
              echo "PostgreSQL 15.x detected. Starting migration process..."
              
              # Step 1: Create database dump
              echo "Step 1/4: Creating database dump..."
              PGPASSWORD="$OLD_PG_PASSWORD" pg_dump -h "$OLD_PG_HOST" -U "$OLD_PG_USER" -d "$OLD_PG_DB" -F c -f /tmp/redash-backup.dump
              
              # Also create SQL dump as backup
              PGPASSWORD="$OLD_PG_PASSWORD" pg_dump -h "$OLD_PG_HOST" -U "$OLD_PG_USER" -d "$OLD_PG_DB" -F p > /tmp/redash-backup.sql
              
              echo "Database dump created successfully"
              ls -lh /tmp/redash-backup.*
              
              # Step 2: Scale down PostgreSQL StatefulSet to 0
              echo "Step 2/4: Scaling down PostgreSQL StatefulSet..."
              RELEASE_NAME="{{ .Release.Name }}"
              NAMESPACE="{{ .Release.Namespace }}"
              
              # Try to find and scale down the PostgreSQL StatefulSet
              # Bitnami PostgreSQL chart typically creates: <release-name>-postgresql or <release-name>-postgresql-primary
              for STATEFULSET_NAME in "${RELEASE_NAME}-postgresql" "${RELEASE_NAME}-postgresql-primary"; do
                if kubectl get statefulset "$STATEFULSET_NAME" -n "$NAMESPACE" > /dev/null 2>&1; then
                  echo "Found StatefulSet: $STATEFULSET_NAME"
                  kubectl scale statefulset "$STATEFULSET_NAME" --replicas=0 -n "$NAMESPACE" --timeout=120s || {
                    echo "WARNING: Failed to scale down StatefulSet $STATEFULSET_NAME. Continuing anyway..."
                  }
                  echo "Waiting for PostgreSQL pods to terminate..."
                  sleep 10
                  break
                fi
              done
              
              # Step 3: Delete the PostgreSQL PVC so PostgreSQL 18 can start fresh
              echo "Step 3/4: Deleting PostgreSQL PVC (data is safely backed up in dump files)..."
              # Bitnami PostgreSQL typically creates PVCs like: <release-name>-postgresql-data-0 or <release-name>-postgresql
              for PVC_NAME in "${RELEASE_NAME}-postgresql-data-0" "${RELEASE_NAME}-postgresql-data" "${RELEASE_NAME}-postgresql"; do
                if kubectl get pvc "$PVC_NAME" -n "$NAMESPACE" > /dev/null 2>&1; then
                  echo "Found PVC: $PVC_NAME"
                  echo "Deleting PVC to allow PostgreSQL 18 to start with a fresh data directory..."
                  echo "NOTE: All data has been backed up to /tmp/redash-backup.dump and /tmp/redash-backup.sql"
                  kubectl delete pvc "$PVC_NAME" -n "$NAMESPACE" --timeout=120s || {
                    echo "WARNING: Failed to delete PVC $PVC_NAME. PostgreSQL 18 may fail to start."
                    echo "You may need to manually delete this PVC: kubectl delete pvc $PVC_NAME -n $NAMESPACE"
                    echo "The data is safely backed up in the migration storage PVC."
                  }
                  break
                fi
              done
              
              echo "Step 4/4: Migration preparation complete!"
              echo "Dump files are stored at: /tmp/redash-backup.dump and /tmp/redash-backup.sql"
              echo "PostgreSQL 15 has been stopped and PVC handled."
              echo "Helm upgrade will now start PostgreSQL 18 with a fresh data directory."
              echo "The post-upgrade hook will restore the data automatically."
            else
              echo "PostgreSQL version is not 15.x (found: $PG_VERSION). Skipping migration."
              echo "If you're upgrading from a different version, manual migration may be required."
            fi
        env:
        - name: PGHOST
          value: {{ $postgresqlFullname }}
        - name: PGPORT
          value: "5432"
        - name: PGUSER
          value: {{ .Values.postgresql.auth.username | quote }}
        - name: PGDATABASE
          value: {{ .Values.postgresql.auth.database | quote }}
        - name: PGPASSWORD
          valueFrom:
            secretKeyRef:
              name: {{ .Release.Name }}-postgresql
              key: postgres-password
        volumeMounts:
        - name: migration-storage
          mountPath: /tmp
      volumes:
      - name: migration-storage
        {{- if .Values.postgresqlMigration.storage.pvcName }}
        persistentVolumeClaim:
          claimName: {{ .Values.postgresqlMigration.storage.pvcName }}
        {{- else }}
        emptyDir: {}
        {{- end }}
---
apiVersion: batch/v1
kind: Job
metadata:
  name: "{{ .Release.Name }}-postgres-restore"
  labels:
    {{- include "redash.labels" . | nindent 4 }}
    app.kubernetes.io/component: postgres-restore
  annotations:
    # This hook runs AFTER the upgrade to restore the database
    "helm.sh/hook": post-upgrade
    "helm.sh/hook-weight": "-6"
    "helm.sh/hook-delete-policy": before-hook-creation,hook-succeeded
spec:
  ttlSecondsAfterFinished: 3600
  template:
    metadata:
      name: "{{ .Release.Name }}-postgres-restore"
      labels:
        {{- include "redash.selectorLabels" . | nindent 8 }}
        app.kubernetes.io/component: postgres-restore
    spec:
      serviceAccountName: {{ include "redash.serviceAccountName" . }}
      restartPolicy: Never
      containers:
      - name: postgres-restore
        image: postgres:18-alpine
        command:
          - /bin/sh
          - -c
          - |
            set -e
            echo "Waiting for PostgreSQL 18 to be ready..."
            
            NEW_PG_HOST="{{ $postgresqlFullname }}"
            NEW_PG_USER="{{ .Values.postgresql.auth.username }}"
            NEW_PG_DB="{{ .Values.postgresql.auth.database }}"
            NEW_PG_PASSWORD="{{ .Values.postgresql.auth.password }}"
            
            # Wait for PostgreSQL 18 to be ready (with timeout)
            MAX_WAIT=300
            WAITED=0
            until PGPASSWORD="$NEW_PG_PASSWORD" psql -h "$NEW_PG_HOST" -U "$NEW_PG_USER" -d "$NEW_PG_DB" -c "SELECT 1;" > /dev/null 2>&1; do
              if [ $WAITED -ge $MAX_WAIT ]; then
                echo "ERROR: PostgreSQL 18 did not become ready within $MAX_WAIT seconds"
                exit 1
              fi
              echo "Waiting for PostgreSQL 18 to be ready... ($WAITED/$MAX_WAIT seconds)"
              sleep 5
              WAITED=$((WAITED + 5))
            done
            
            echo "PostgreSQL 18 is ready. Checking for dump files and database state..."
            
            # Check if database already has Redash data (check for alembic_version table which indicates migrations have run)
            HAS_REDASH_DATA=$(PGPASSWORD="$NEW_PG_PASSWORD" psql -h "$NEW_PG_HOST" -U "$NEW_PG_USER" -d "$NEW_PG_DB" -t -c "SELECT COUNT(*) FROM information_schema.tables WHERE table_schema = 'public' AND table_name = 'alembic_version';" 2>/dev/null | tr -d ' ' || echo "0")
            TABLE_COUNT=$(PGPASSWORD="$NEW_PG_PASSWORD" psql -h "$NEW_PG_HOST" -U "$NEW_PG_USER" -d "$NEW_PG_DB" -t -c "SELECT COUNT(*) FROM information_schema.tables WHERE table_schema = 'public';" 2>/dev/null | tr -d ' ' || echo "0")
            
            # Check if dump files exist
            if [ -f /tmp/redash-backup.dump ] || [ -f /tmp/redash-backup.sql ]; then
              # Only restore if database is empty or doesn't have Redash data yet
              if [ "$HAS_REDASH_DATA" = "0" ] && [ "$TABLE_COUNT" = "0" ]; then
                echo "Database is empty. Restoring from dump file..."
                
                if [ -f /tmp/redash-backup.dump ]; then
                  # Restore from custom dump format
                  echo "Restoring from dump file..."
                  PGPASSWORD="$NEW_PG_PASSWORD" pg_restore -h "$NEW_PG_HOST" -U "$NEW_PG_USER" -d "$NEW_PG_DB" -v --no-owner --no-privileges /tmp/redash-backup.dump || {
                    echo "pg_restore failed, trying SQL restore..."
                    if [ -f /tmp/redash-backup.sql ]; then
                      PGPASSWORD="$NEW_PG_PASSWORD" psql -h "$NEW_PG_HOST" -U "$NEW_PG_USER" -d "$NEW_PG_DB" < /tmp/redash-backup.sql
                    else
                      echo "ERROR: SQL dump file not found"
                      exit 1
                    fi
                  }
                elif [ -f /tmp/redash-backup.sql ]; then
                  echo "Restoring from SQL dump file..."
                  PGPASSWORD="$NEW_PG_PASSWORD" psql -h "$NEW_PG_HOST" -U "$NEW_PG_USER" -d "$NEW_PG_DB" < /tmp/redash-backup.sql
                fi
                
                echo "Database restore completed successfully"
                
                # Clean up dump files after successful restore to prevent re-restoration on future upgrades
                echo "Cleaning up dump files to prevent re-restoration..."
                rm -f /tmp/redash-backup.dump /tmp/redash-backup.sql
                echo "Dump files cleaned up."
              else
                echo "Database already contains data (found $TABLE_COUNT tables, Redash data: $HAS_REDASH_DATA)."
                echo "Skipping restore - migration has already been completed."
                echo "Cleaning up old dump files..."
                rm -f /tmp/redash-backup.dump /tmp/redash-backup.sql
              fi
            else
              if [ "$HAS_REDASH_DATA" = "1" ] || [ "$TABLE_COUNT" -gt 0 ]; then
                echo "Database already contains data. No migration needed."
              else
                echo "WARNING: No dump files found and database is empty."
                echo "This might be expected if:"
                echo "  1. This is a fresh installation"
                echo "  2. PostgreSQL was not version 15.x before upgrade"
                echo "  3. Migration storage (PVC) was not configured correctly"
                echo ""
                echo "Skipping restore. Redash schema migrations will run next."
              fi
            fi
        env:
        - name: PGHOST
          value: {{ $postgresqlFullname }}
        - name: PGPORT
          value: "5432"
        - name: PGUSER
          value: {{ .Values.postgresql.auth.username | quote }}
        - name: PGDATABASE
          value: {{ .Values.postgresql.auth.database | quote }}
        - name: PGPASSWORD
          valueFrom:
            secretKeyRef:
              name: {{ .Release.Name }}-postgresql
              key: postgres-password
        volumeMounts:
        - name: migration-storage
          mountPath: /tmp
      volumes:
      - name: migration-storage
        {{- if .Values.postgresqlMigration.storage.pvcName }}
        persistentVolumeClaim:
          claimName: {{ .Values.postgresqlMigration.storage.pvcName }}
        {{- else }}
        emptyDir: {}
        {{- end }}
{{- end }}
